<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Gibbon.Passes.Unariser</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">gibbon-0.3: A compiler for operating on serialized data</span><ul class="links" id="page-menu"><li><a href="src/Gibbon.Passes.Unariser.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Gibbon.Passes.Unariser</p></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:unariser">unariser</a> :: <a href="Gibbon-L3-Syntax.html#t:Prog3" title="Gibbon.L3.Syntax">Prog3</a> -&gt; <a href="Gibbon-Common.html#t:PassM" title="Gibbon.Common">PassM</a> <a href="Gibbon-L3-Syntax.html#t:Prog3" title="Gibbon.L3.Syntax">Prog3</a></li><li class="src short"><a href="#v:unariserExp">unariserExp</a> :: <a href="file:///nix/store/8l12vmymy3adw2m02pf73xq5xjf6mfwp-ghc-9.4.5-doc/share/doc/ghc/html/libraries/base-4.17.1.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Gibbon-Language-Syntax.html#t:DDefs" title="Gibbon.Language.Syntax">DDefs</a> <a href="Gibbon-L3-Syntax.html#t:Ty3" title="Gibbon.L3.Syntax">Ty3</a> -&gt; ProjStack -&gt; <a href="Gibbon-Language-Syntax.html#t:Env2" title="Gibbon.Language.Syntax">Env2</a> <a href="Gibbon-L3-Syntax.html#t:Ty3" title="Gibbon.L3.Syntax">Ty3</a> -&gt; <a href="Gibbon-L3-Syntax.html#t:Exp3" title="Gibbon.L3.Syntax">Exp3</a> -&gt; <a href="Gibbon-Common.html#t:PassM" title="Gibbon.Common">PassM</a> <a href="Gibbon-L3-Syntax.html#t:Exp3" title="Gibbon.L3.Syntax">Exp3</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:unariser" class="def">unariser</a> :: <a href="Gibbon-L3-Syntax.html#t:Prog3" title="Gibbon.L3.Syntax">Prog3</a> -&gt; <a href="Gibbon-Common.html#t:PassM" title="Gibbon.Common">PassM</a> <a href="Gibbon-L3-Syntax.html#t:Prog3" title="Gibbon.L3.Syntax">Prog3</a> <a href="src/Gibbon.Passes.Unariser.html#unariser" class="link">Source</a> <a href="#v:unariser" class="selflink">#</a></p><div class="doc"><p>This pass gets ready for Lower by converting most uses of
 projection and tuple-construction into finer-grained bindings.</p><p>OUTPUT INVARIANTS:</p><ol><li value="1">only flat tuples as function arguments (no nesting), all
 arguments immediately present, e.g. `AppE &quot;f&quot; (MkProd [x,y,z])`
  rather than `AppE &quot;f&quot; (MkProdE [x,MkProdE[y,z]])`</li><li value="2">The only MkProdE allowed outside of function operands is within
 return/tail position (of a function or If branch).</li><li value="3">Primitives are allowed to return tuples, but are let-bound
 (these will turn into LetPrimCall).  The references to these tuples
 are all of the form `ProjE i (VarE v)` and they are then
 transformed to varrefs in lower.</li></ol><dl><dt>Aditya Gupta, Oct 2021</dt><dd>NOTE: I am limiting flattening to only intermediate expressions. i.e. the tail value
 of main expression is a terminal expression and shouldn't be flattened.
 We can recursively propagate terminality based on expression type. This way all intermediate
 expressions will enjoy benefit from flattening, but we still retain same output for terminal expressions.
 We can have a separate function to recover after unarising but that won't have the env2/ddefs values
 and we won't be able to fuse it into unariser cases. But on the other hands, defining a separate function
 can eliminate missed cases, but there are only few, so combining recovering terminal expressions in unariser
 seems best.</dd></dl></div></div><div class="top"><p class="src"><a id="v:unariserExp" class="def">unariserExp</a> :: <a href="file:///nix/store/8l12vmymy3adw2m02pf73xq5xjf6mfwp-ghc-9.4.5-doc/share/doc/ghc/html/libraries/base-4.17.1.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Gibbon-Language-Syntax.html#t:DDefs" title="Gibbon.Language.Syntax">DDefs</a> <a href="Gibbon-L3-Syntax.html#t:Ty3" title="Gibbon.L3.Syntax">Ty3</a> -&gt; ProjStack -&gt; <a href="Gibbon-Language-Syntax.html#t:Env2" title="Gibbon.Language.Syntax">Env2</a> <a href="Gibbon-L3-Syntax.html#t:Ty3" title="Gibbon.L3.Syntax">Ty3</a> -&gt; <a href="Gibbon-L3-Syntax.html#t:Exp3" title="Gibbon.L3.Syntax">Exp3</a> -&gt; <a href="Gibbon-Common.html#t:PassM" title="Gibbon.Common">PassM</a> <a href="Gibbon-L3-Syntax.html#t:Exp3" title="Gibbon.L3.Syntax">Exp3</a> <a href="src/Gibbon.Passes.Unariser.html#unariserExp" class="link">Source</a> <a href="#v:unariserExp" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.27.0</p></div></body></html>